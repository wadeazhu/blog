---
lang: zh-CN
title: 最新javascript面试题
description: 页面的描述
---

## 最新javascript面试题

### `JavaScript`的变量有哪些类型？

- 分为两种：基础类型和引用类型。基础类型目前有六种，分别是`boolean`、`null`、`undefined`、`number`、`string`、`symbol`、`bigint`
- 除了以上的基础类型之外，其他就是引用类型了`Object`

### 基础类型和引用的区别？

- 它们在内存中存储的方式不同。基础类型存储的是值，而引用类型存储的是指向内存中某个空间的指针；
- 基础类型赋值就是把值赋给另外一个变量，而引用类型的赋值是赋值的原来变量的指针，所以当引用类型发生改变时，只要是指向同一个指针的变量的都会发生改变。

### 函数参数是对象时会发生什么问题？

- 函数参数是对象时，相当于是将对象的指针传递给了函数，如果在函数的内部改变了对象的值，外面对象的值也会发生改变，数组也是如此。

### `typeof`和`instanceof`判断变量类型的区别？

- `typeof`对于基础类型除了`null`以外都可以显示正确的类型，对于数组和对象都会显示`object`，对于函数会显示`function`。对于`null`返回`object`(这个可以是以前遗留的bug，现在的解释是`null`被认为`object`对象的一个占位符，从而解释了这一个矛盾)
- `instanceof`主要是用来判断引用类型，它的原理是根据原型链来查找。一般用于判断对象是否是某个类或者子类的实例。

### 有没有更好的判断变量类型的方法？

- 可以使用`Object.prototype.toString.call(var)`，可以更加准确的判断某个变量的类型。

### 类数组转为数组的方式有哪些？

```javascript
[].slice.call(arguments)
Array.from(arguments)
[...arguments]
```

### 如何判断一个变量是否是数组？

```javascript
// 通过Array.isArray()方法, 此方法放回boolean
Array.isArray(arr)

// 通过原型是不是一样判断
arr.__proto__ = Array.prototype

// 通过instanceof判断，是否是Array的实例
arr instanceof Array

// 通过判断构造函数是否是指向Array
arr.constructor = Array

// 使用Object.prototype.toString.call()
Object.prototype.toString.call(arr) === '[object Array]'
```

### 将多维数组扁平化？

```js
// 第一种用原生的方法
function flatten(arr) {
  return arr.flat(Infinity);
}

// 第二种使用递归的方法
function flatten(arr) {
  const ret = [];
  while (arr.length) {
    const item = arr.shift();
    if (Array.isArray(item)) {
      arr.unshift(...item);
    } else {
      ret.push(item);
    }
  }
  return ret;
}
```

### 数组去重？

```javascript
// 第一种使用set特性，自身具备去重的效果
function unique(arr) {
  return [...new Set(arr)];
}

// 第二种，循环每个值，看是否存在数组中，去掉重复的
function unique(arr) {
  return arr.filter((v, i, a) => {
    return a.indexOf(v) === i;
  })
}

// 第三种使用map唯一的特性
function unique(arr) {
  const tmp = new Map();
  return arr.filter(v => {
    return !tmp.has(v) && tmp.set(v);
  })
}
```

### 字符串的`test`、`match`、`search`它们之间的区别？

```js
`test` 是检测字符串是否匹配某个正则，返回布尔值；
/[a-z]/.test(1);  // false

`match` 是返回检测字符匹配正则的数组结果集合，没有返回`null`；
'1AbC2d'.match(/[a-z]/ig);  // ['A', 'b', 'C', 'd']

`search` 是返回正则匹配到的下标，没有返回`-1`。
'1AbC2d'.search(/[a-z]/);  // 2
```

### 字符串的`slice`、`substring`、`substr`它们之间的区别？

```js
`slice`是返回字符串开始至结束下标减去开始下标个数的新字符串，下标是负数为倒数；
'abcdefg'.slice(2,3);  // c  // 3 - 2
'abcdefg'.slice(3,2);  // ''  // 2 - 3
'abcdefg'.slice(-2,-1);  // f  // -1 - -2

`substring`和`slice`正常截取字符串时相同，负数为0，且下标值小的为开始下标；
'abcdefg'.substring(2,3);  //c  // 3 - 2
'abcdefg'.substring(3,2);  // c  // 3 - 2 
'abcdefg'.substring(3,-3);  // abc  // 3 - 0

`substr`返回开始下标开始加第二个参数(不能为负数)个数的新字符串。
'abcdefg'.substr(2, 3);  // cde
'abcdefg'.substr(3, 2);  // de
'abcdefg'.substr(-3, 2); // ef
```

### `Number('123')`和`new Number('123')`有什么区别？

- `Number('123')`是一个转换函数，会尝试把参数转为整数类型；而`new Number('123')`则不同，这是一个构造函数，它的结果是实例化出来一个对象。
- 同样的情况也适用用`String`和`new String`；`Boolean`和`new Boolean`的情况。

```javascript
typeof Number('123') // number
typeof new Number('123') // object
```

### `==`和`===`的区别？

- `===`会判断两边变量的类型和值是否全部相等，`==`会存在变量类型转换的问题，所以并不推荐使用，只用一种情况会被使用，`var == null`是`var === undefined || var === null`的简写，其余情况一律使用`===`。

### 是否`===`就完全靠谱？

- 也是不一定的，例如`0 === -0`就为`true`，`NaN === NaN`为`false`，判断两个变量是否完全相等可以使用`ES6`新增的`API`，`Object.is(0, -0)`，`Object.is(NaN, NaN)`就可以准确区分。

### 在类型转换中哪些值会被转为`true`？

- 除了`undefined`、`null`、`false`、`NaN`、`''`、`0`、`-0`以外的值都会被转为`true`，包括所有引用类型，即使是空的。

### 什么是基本包装类型？

- 基本类型并不是对象，是不应该有各自方法的，为什么能调用各自的那些方法，是因为在后台对基本类型进行了包装。例如字符串、整数、布尔值，首先会使用各自的构造函数创建对应的实例，这样调用这些方法时就可以正常使用，不过再方法调用结束后，就会将实例给销毁掉，从而又是基本类型。

```js
let s1 = 'hello'
let s2 = s1.substring(2)
↓ 后台包装
let s1 = new String('hello') // 包装
let s2 = s1.substring(2) // 可以调用方法
s1 = null // 销毁
```

### `toString()`和`valueOf`的区别？

- `null`和`undefined`没有以上两个方法。
- `toString`：值类型时返回自身的字符串形式；当是引用类型时，无论是一维或多维数组，将他们拍平成一个字符串，里面的`null`和`undefined`转为空字符串`''`，对象转为`[object Object]`，函数的原样返回字符串形式。
- `valueOf`无论是值类型还是引用类型，大部分情况下都是原样返回，当是`Date`类型时，返回时间戳。
- 在进行字符串强转的时候，`toString`会优先于`valueOf`；在进行数值运算时，`valueOf`会优先于`toString`。
- 当执行`toString`的变量是一个整数类型时，支持传参，表示需要转为多少进制的字符串。

### 谈谈对`this`的理解？

- `this`表示为当前的函数调用方，在运行时才能决定。如谁调用了某个方法，谁就是这个方法执行时的`this`。

有几个特殊情况：

1. 箭头函数，在创建的时候就确定了他的this指向，指向外层的this
2. 当使用 new 关键字调用函数时，函数中的 this 一定是 JS 创建的新对象
3. 可以使用bind、call、apply来修改函数的this指向，但是不能修改箭头函数的指向
4. 在全局作用域下使用this调用调用函数，这时this指向全局作用域

### 改变当前调用`this`的方式？

- `call`：会立即执行调用`call`方法的函数，不过是以第一个参数为`this`的情况下调用，方法内可以传递不等的参数，作为调用`call`方法的参数。
- `apply`：运行方式和`call`是一致的，只是接受的参数不同，不能是不定参数，得是一个数组。
- `bind`：会改变当前的`this`，接受不定参数，不过不会马上执行调用`bind`方法的函数，而是返回一个函数作为结果，执行后才是调用函数的结果。

### 谈谈对闭包的理解？

- 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

### 谈谈对原型以及原型链的理解？

- 每一个`JavaScript`引用类型(数组/对象/函数)都有一个`__proto__`属性，这个属性是一个对象格式，也就是原型属性。在原型属性里面有一个`constructor`属性，这个属性是这个引用类型的构造函数，在`constructor`里面又有一个`prototype`的属性，这个属性又指回了引用类型的原型属性。
- 原型链就是通过对象的`__proto__`属性层层连接起来形成的，而构造函数的`prototype`是一个对象属性，再构造函数实例化时就会将这个属性赋值给实例化后对象的`__proto__`属性，所以函数的继承也会相应的构造出对象的原型链。

### 原型继承的方式有哪些？

- 原型链继承、借用构造函数继承、组合继承、原型式继承、寄生组合继承等等。最优化的继承方式是寄生组合继承：

```js
function Parent(name) {
  this.name = name;
}
function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child
```

### 什么是垃圾回收机制？

- 在程序执行的过程中，解释器会为创建出来的变量分配内存来存储这些变量的实体，执行环境会负责管理代码执行过程中使用到的内存，而何时划出新的内存以及何时把占用的内存释放出来的这样一套内存自动管理机制就是垃圾回收机制。这种周期性的回收策略主要有两种。
- 标记清除：当变量进入环境时，就将这个变量标记为'进入环境'，而当这个变量离开环境时，则将其标记为'离开环境'。垃圾收集器会给内存中的每个变量都做上标记，然后它会去掉环境中的变量以及被环境中变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集器完成内存清除工作。
- 引用计数：追踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋给该变量时，这个变量的引用次数就是1。相反如果包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当为0时，这说明没有办法再访问这个值了，因此垃圾收集器下次运行时，就会释放该值占用的内存。

### 如何解决引用类型变量共享的问题？

- 可以对引用类型进行深拷贝解决，最简单暴力的深拷贝是`JSON.parse(JSON.stringify(obj))`，不过也会存在诸多问题，更加完善的深拷贝需要手写递归方法对不同参数分别处理

### 函数防抖和节流的区别？

- 函数防抖指一定时间内没有再次触发函数，就执行该函数，否则重新计时；节流是规定某个时间内只能执行一次函数。以`wow`为例：
- 函数防抖：`2.5s`施法的寒冰箭，再读条的过程中，你身子抖动打断了施法，再次触发技能时麻烦您重新读条。
- 函数节流：火冲为瞬发技能，不过你规定`cd`为`8s`，所以即使`8s`内按了`10`次，也只能来`1`发，节省点体力吧。

### `var`、`let`、`const`的区别 ？

- `var`类型会有变量提升的情况，也就是说声明会首先提升到当前作用域的顶端，在使用到时再读取定义的值。
- 在全局作用域下定义的`var`变量会挂载到作用域链的顶端`window`下，而`let`和`const`全局定义时在作用域链中要低一级。
- `let`和`const`没有变量提升的情况，必须要先声明再使用，否则就会出现暂时性死区的情况。
- 而且它们的作用域存在最近的大括号之内，也就是块级作用域，并且一经定义后，同一个作用域内不能再次定义。
- 而`const`和`let`的区别在于一经定义后不得再次改变`const`定义的值，如果是引用类型只要不改变指针，改变里面的值是没问题的。
- `const`定义时必须赋值，`let`不必。

### `Set`、`WeakSet`的区别？

- `Set`类型内存储的是不会重复的值，建议存储基础类型的值，因为引用类型的指针都不同。
- `WeakSet`只能存储对象参数，否则会报错，而且是存储的引用类型的弱引用。
- `WeakSet`不可被迭代，不支持`forEach`、`for-of`、`keys`、`values`方法，没有`size`属性。

```ini
const set = new Set();
const obj = {name: 'cc'};
set.add(obj);
obj = null;
[...set][0]; // {name: 'cc'} 转数组后依然可以访问到

const weakSet = new WeakSet();
const obj = {};
weakSet.add(obj);
obj = null;  // 会移除引用
weakSet.has(obj); // false
```

### `Map`、`WeakMap`的区别？

- `Map`是解决了对象`key`会被自动转为字符串的一种增强`key/value`集合。
- `WeakMap`是弱引用的`Map`集合，`key`必须是非`null`的对象格式，同样不可以被迭代。

```dart
const obj = Object.create(null);
obj[1] = 'cc';
obj['1']; // cc

const map = new Map();
map.set(1, 'cc');
map.has('1');  // false   1 和 '1'不会被转换
```

### 箭头函数和普通函数的区别？

- 箭头函数的`this`是由包裹它的普通函数的`this`来决定；
- 不能作为构造函数, `Generator`函数；
- 参数不能使用`arguments`访问，需要使用`Es6`的不定参数访问；
- 使用`bind`方法无效。

### 请实现plus(1)(2)(3)(4)等于10？

```javascript
// 方法1：
function plus(n) {
  let sum = n;
  const _plus = function (n) {
    sum += n;
    return _plus;
  };
  _plus.toString = function () {
    return sum;
  };
  return _plus;
}

// 方法2：
function multi() {
  const args = [].slice.call(arguments);
  const fn = function () {
    const newArgs = args.concat([].slice.call(arguments));
    return multi.apply(this, newArgs);
  }
  fn.toString = function () {
    return args.reduce(function (a, b) {
      return a + b;
    })
  }
  return fn;
}
```

### 谈谈对`class`的理解 ？

- `JavaScript`没有真正的类，一直也是通过函数加原型的形式来模拟，`class`也不例外，只是语法糖，本质还是函数。需要先声明再使用，内部的方法不会被遍历，且没有函数的`prototype`属性。不过相较`ES6`之前无论是定义还是继承都好理解了很多。继承主要是使用`extends`和`super`关键字，本质类似于`ES5`的寄生组合继承：

```scala
class Parent {
  constructor(name) {
    this.name = name;
  }
}
class Child extends Parent {
  constructor(name, age) {
    super(name);  // 相当于Parent.call(this, name)
    this.age = age;
  }
} 
```

### 谈谈对`Promise`的理解 ？

- `Promise`主要解决的问题就是异步回调嵌套过深造成代码难以维护和理解。
- `Promise`构造函数内的代码是同步执行的，而之后`then`或`catch`方法是异步执行的，构造函数接受两个函数参数`resolve`和`reject`，它们执行时接受的参数分别会传递给`then`和`catch`表示成功的回调以及失败回调接受到的值。
- `Promise`一共有三种状态`pending`等待状态、`resolved`已完成状态、`rejected`已拒绝状态，状态的改变只能由等待转为已完成或等待转为已拒绝状态，而且状态的改变只会发生一次。
- 必须要实现`then`方法且方法里必须要返回一个`Promise`对象，如果是返回其他的类型会尝试包装成`Promise`对象；
- `then`可以被链式的调用。
- 缺点是`Promise`链中途无法取消；错误需要通过回调函数捕获。

### 谈谈对`ES-Module`的理解 ？

- `ES-Module`是`ES6`原生支持模块化方案，通过`import`来引入模块，通过`export default`或`export`来导出模块。

### 谈谈对`Proxy`的理解 ？

- 和`Object.defineProperty`有些类似，它的作用是用来自定义对象中操作。`Proxy`的构造函数接受两个参数，第一个参数是需要代理的对象，第二个参数是一个对象，里面会定义`get`和`set`方法，当代理对象中的某个值被访问或重新赋值就会触发相应的`get`和`set`方法。`vue3.0`就抛弃了`Object.defineProperty`而拥抱了`Proxy`，它的优点是只需要代理一次，对象内的值发生了改变就会被感知到，不再需要像以前为对象的每个值进行数据劫持；而且以前对象的新增，数组的下标设置`0`清空等情况都可以被感知到，在响应式里也不在需要为数组和对象收集两次依赖，相信会大大提升性能。

### 谈谈对`Generator`的理解？

- 是`JavaScript`方便创建迭代器的新语法，在方法名前面添加`*`号，表示这个方法是一个生成器函数，在函数内部配合`yield`关键字指定`next()`方法返回值及顺序。
- `yield`类似与在函数内部打上了断点，`yield`就是每一处的`debugger`，执行`next()`方法后进入下一个断点。
- 不能使用箭头函数来创建生成器。

### 谈谈对`async`及`await`的理解 ？

- 是`Genneator`的语法糖形式，解决的问题是以同步的形式写异步代码，让代码流程能很好的表示执行流程。在函数的前面加上`async`表明是一个异步函数，函数的内部需要配合`await`关键字使用，每一个`await`关键字相当于是`yield`，会暂停函数的执行，直到异步函数执行完毕后内部会自动执行`next()`方法，执行之后的代码，函数的返回结果是一个`Promise`对象。因为是以同步的形式书写异步代码，所以错误捕获是使用`try/catch`的形式。

### 谈谈对`Event-Loop`的理解 ？

- `JavaScript`的执行机制简单来说就先执行同步代码，然后执行异步代码，而异步的代码里面又分为宏任务代码和微任务代码，先执行微任务，然后执行宏任务。首先会将所有`JavaScript`作为一个宏任务执行，遇到同步的代码就执行，然后开始分配任务，遇到宏任务就将它的回调分配到宏任务的队列里，遇到微任务的回调就分配到微任务的队列里，然后开始执行所有的微任务。执行微任务的过程还是遵循先同步然后分配异步任务的顺序，微任务执行完毕之后，一次`Event-Loop`的`Tick`就算完成了。接着挨个去执行分配好的宏任务，在每个宏任务里又先同步后分配异步任务，完成下一次`Tick`，循环往复直到所有的任务全部执行完成。
- 微任务包括：`process.nextTick` ，`promise` ，`MutationObserver`。
- 宏任务包括：`script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`。

### 对浏览器或元素的各种距离参数你知道哪些？

- `document.documentElement.clientHeight`：当前窗口内容区 + 内边距的高度
- `window.innerHeight`: 当前窗口内容区 + 内边距 + 边框 + 滚动条高度
- `window.outerHeight`：整个浏览器的高度(包括工具栏)
- 
- `clientHeight`: 当前元素内容区 + 内边距的高度
- `clientTop`: 当前元素上边框的宽度
- `offsetHeight`: 当前元素内容区 + 内边距 + 边框 + 滚动条的高度
- `offsetTop`: 当前元素的边框距离父元素上外边距的距离
- `scrollHeight`: 当前内部可以滚动区域的高度，如果不能滚动则为自己内容区 + 内边距的高度
- `scrollTop`: 当前元素滚动离顶部的距离

### 怎么确定当前浏览器的类型？

- 通过`navigator.userAgent`获取浏览器信息，根据里面的关键字来确定。

### 什么是简单请求和复杂请求？

- 简单请求：

1. 请求方法仅限`get`、`head`、`post`。
2. `Content-type`仅限`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`。

- 复杂请求： 不符合以上条件者就为复杂请求，首先会发起一个`option`方法的预检请求，来知道服务端是否允许跨域请求。 有一个坑就是服务端设置了`CORS`，但当客户端发其复杂请求时会验证`Authorization`字段，但是客户端并没有，所以需要将`option`方法过滤掉。

### 从输入域名到页面显示都经历了什么？

- 首先将域名`DNS`解析为对应的`IP`地址，然后通过`Socket`发送数据，经过`tcp`协议的三次握手，向该地址发起`HTTP`请求，服务器处理，浏览器收到`HTTP`响应的数据，关闭`tcp`连接，开始渲染。

### 谈谈浏览器的渲染机制？

- 书写的`JavaScript`、`Css`、`Html`在网络传输中都是`0`和`1`的字节流，所以浏览器首先会把接受到的这些字节流转为字符串。然后首先将`html`字节流解析为字符串，对字符串进行标记化，确定标签名以及里面的内容，然后生成对应的`node`节点，根据节点的结构关系生成`DOM`树。然后开始解析`css`，和解析`html`类似，`css`一般有嵌套或继承的情况，浏览器会从里到外的递归来确定每个节点的样式是什么，从而生成一颗`CSSOM`树。最后是将这两颗树结合起来生成一颗渲染树，浏览器根据渲染树进行布局，调用`GPU`绘制生成页面显示在屏幕上。

### 什么是重绘和回流？

- 重绘是节点的外观发生改变而不改变布局时，如改变了`color`这个行为；回流是指改变布局或几何属性发生改变时引起的行为，如添加移除`Dom`，改变尺寸。它们频繁的触发会影响页面性能。
- 回流一定触发重绘，而重绘不一定引起回流。回流的成本比重绘高很多，而且子节点的回流，可能引起父节点一系列的回流。

### 如何减少重绘和回流？

- 使用`transform`替代位移，使用`translate3d`开启`GPU`加速
- 尽量使用`visibility`替代`display:none`
- 不要使用`tanle`布局
- 不要在循环里读取节点的属性值
- 动画速度越快，回流次数越少

### 什么是事件流/模型？

- 当某一个事件被触发时，分为三个阶段：
- 1.事件通过捕获从`window` => `document` => `body` => 目标元素
- 2.事件到达注册的目标上
- 3.目标元素通过冒泡返回到`window`，沿途触发相同类型的事件

### 什么是事件代理？

- 利用事件流的冒泡特性，将子节点的事件绑定在父节点上，然后在回调里面使用事件对象进行区分，优点是节省内存且不需要给子节点销毁事件。

### 什么是事件对象？

- 这个对象里面存放着触发事件的状态，如触发事件的当前元素，键盘事件是哪个按键触发的，滚动事件的位置等等。