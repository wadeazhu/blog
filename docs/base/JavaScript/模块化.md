---
title: 模块化
---

## 模块

模块可以把一个大的工程拆分成互相依赖的小文件，再用简单的方式拼接起来，在各大语言中都存在，就连css中都存在@import来导入css，但是在es6之前没有。所以社区定义了两种模块的规范，一种是CommonJS， 一种是AMD，前者用于服务端，后者用于浏览器端。后面再es6在语言层面实现了模块的功能，可以代替这两个规范。ES6的设计之初是用于静态解析模块，编译时就能确定依赖关系。所以这与CommonJS和AMD需要运行时解析完全不同。



CommonJS加载的是整个模块，引入的是整个的对象，但是ES6模块引用的是对应属性或者方法，其他的不加载。

```js
// -- CommonJS
const { join, resolve, relative } = require("path")
// 相当于
const _path = require("path")
const join = _path.join
const resolve = _path.resolve
const relative = _path.relative

// -- ES6 这里只引入了这几个方法，其他的没有加载
import { join, resolve, relative } from 'path'
```

ES6模块的另一个特点，模块依赖过程中值的引入是可以实时获取变化后的值

```js
// test1.js
export let str = 'hello'
setTimeout(() => {
    str = 'world'
})

// test2.js
import { str } from 'test1.js'
setTimeout( () => {
    console.log(str)  // world
}, 1000 )
```



ES6 优点：

1. 静态加载，编译的时候就完成了模块的加载，相比于CommonJS来说效率更高
2. 由于是静态加载，所以后面给静态分析有很好的扩展，比如类型检查、宏
3. 不在需要UMD模块格式
4. 以后浏览器的api可以用模块格式提供，而不需要全局变量和命名空间来完成

## export

用于将规定模块的对外接口，一个模块就是一个对立的空间，如果想从外面访问到内部属性或者方法， 就必须使用export命令。export命令后面跟一个声明的写法、或者一个大括号，里面是一组需要导出的变量或者方法。

```js
// 写法一：
export const str = 'hello world'

// 写法二： 推荐这种写法， 将需要导入的
const num = 12
const date = new Date()

export { num, date }
```

export导入的其他设置

```js
// 重命名
const str = 'hello world'
export { str as str1 }
```



export可以出现在模块的任何位置，但只要是模块顶层就可以。如果是在块级作用域中就会报错

```js
const str = 'hello'
if( str ==== 'hello' ) {
    export const str2 = 'world' //这里会报错，因为违背了静态解析
}
```



## import

import可以导入export导出的内容。





















